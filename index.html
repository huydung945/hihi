<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Universe</title>
<style>
    body {
        margin: 0;
        overflow: hidden;
        background: #000;
    }
</style>
</head>

<body>
<script type="module">
import * as THREE from "https://cdn.skypack.dev/three@0.136.0";
import { OrbitControls } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls";


const scene = new THREE.Scene();
scene.background = new THREE.Color("#120014");

const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 1, 1000);
camera.position.set(0, 4, 22);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

window.addEventListener("resize", () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
});

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enablePan = false;


const gu = { time: { value: 0 } };

let sizes = [];
let shift = [];

function pushShift() {
    shift.push(
        Math.random() * Math.PI,
        Math.random() * Math.PI * 2,
        (Math.random() * 0.9 + 0.1) * Math.PI * 0.1,
        Math.random() * 0.9 + 0.1
    );
}

let pts = new Array(50000).fill().map(() => {
    sizes.push(Math.random() * 1.5 + 0.5);
    pushShift();
    return new THREE.Vector3()
        .randomDirection()
        .multiplyScalar(Math.random() * 0.5 + 9.5);
});

for (let i = 0; i < 100000; i++) {
    let r = 10, R = 40;
    let rand = Math.pow(Math.random(), 1.5);
    let radius = Math.sqrt(R * R * rand + (1 - rand) * r * r);
    pts.push(new THREE.Vector3().setFromCylindricalCoords(
        radius,
        Math.random() * Math.PI * 2,
        (Math.random() - 0.5) * 2
    ));
    sizes.push(Math.random() * 1.5 + 0.5);
    pushShift();
}

const g = new THREE.BufferGeometry().setFromPoints(pts);
g.setAttribute("sizes", new THREE.Float32BufferAttribute(sizes, 1));
g.setAttribute("shift", new THREE.Float32BufferAttribute(shift, 4));

const m = new THREE.PointsMaterial({
    size: 0.125,
    transparent: true,
    depthTest: false,
    blending: THREE.AdditiveBlending,
    onBeforeCompile: shader => {
        shader.uniforms.time = gu.time;

        shader.vertexShader = `
            uniform float time;
            attribute float sizes;
            attribute vec4 shift;
            varying vec3 vColor;
            ${shader.vertexShader}
        `
        .replace(`gl_PointSize = size;`, `gl_PointSize = size * sizes;`)
        .replace(`#include <color_vertex>`, `
            #include <color_vertex>
            float d = length(abs(position) / vec3(40.,10.,40));

            vec3 core = vec3(1.0, 1.0, 0.75);
            vec3 mid  = vec3(1.0, 0.8, 0.2);
            vec3 outc = vec3(0.5, 0.25, 0.05);

            vec3 c1 = mix(core, mid, smoothstep(0.0, 0.4, d));
            vec3 c2 = mix(mid, outc, smoothstep(0.4, 1.0, d));
            vColor = mix(c1, c2, d) * 0.65;
        `)
        .replace(`#include <begin_vertex>`, `
            #include <begin_vertex>
            float t = time;
            float mt = mod(shift.x + shift.z * t, PI2);
            float ms = mod(shift.y + shift.z * t, PI2);
            transformed += vec3(
                cos(ms) * sin(mt),
                cos(mt),
                sin(ms) * sin(mt)
            ) * shift.a;
        `);

        shader.fragmentShader = `
            varying vec3 vColor;
            ${shader.fragmentShader}
        `
        .replace(
            `vec4 diffuseColor = vec4( diffuse, opacity );`,
            `vec4 diffuseColor = vec4( vColor, smoothstep(0.5,0.1,length(gl_PointCoord-0.5)) );`
        );
    }
});

const galaxy = new THREE.Points(g, m);
galaxy.rotation.order = "ZYX";
galaxy.rotation.z = 0.2;
scene.add(galaxy);


const texture = new THREE.TextureLoader().load("./Screenshot 2026-01-15 163655.png");

const avatarMat = new THREE.ShaderMaterial({
    transparent: true,
    depthTest: false,
    side: THREE.DoubleSide,
    uniforms: { map: { value: texture } },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D map;
        varying vec2 vUv;

        vec3 saturate(vec3 c, float a) {
            float g = dot(c, vec3(0.299,0.587,0.114));
            return mix(vec3(g), c, a);
        }

        void main() {
            vec2 uv = vUv - 0.5;
            float r = length(uv);
            if (r > 0.5) discard;

            vec4 tex = texture2D(map, vUv);
            vec3 col = tex.rgb;

            

            float alpha = smoothstep(0.5, 0.47, r);
            gl_FragColor = vec4(col, tex.a * alpha);
        }
    `
});

const avatarGeo = new THREE.PlaneGeometry(4.5, 4.5 );
const avatar = new THREE.Mesh(avatarGeo, avatarMat);
avatar.position.set(0, 0, 0);
scene.add(avatar);


const clock = new THREE.Clock();

renderer.setAnimationLoop(() => {
    controls.update();
    const t = clock.getElapsedTime() * 0.5;
    gu.time.value = t * Math.PI;
    galaxy.rotation.y = t * 0.05;
    renderer.render(scene, camera);
});
</script>
</body>
</html>
